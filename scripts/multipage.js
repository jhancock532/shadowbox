#!/usr/bin/env node
"use strict";

const puppeteer = require("puppeteer");
const chalk = require("chalk");
const fs = require("fs");
const { parse, format } = require("url");

const timeout = 5000;

/**
 * Chrome functions
 *
 */
// #region
async function waitForSelectors(selectors, frame, options) {
  for (const selector of selectors) {
    try {
      return await waitForSelector(selector, frame, options);
    } catch (err) {
      console.error(err);
    }
  }
  throw new Error(
    "Could not find element for selectors: " + JSON.stringify(selectors)
  );
}

async function scrollIntoViewIfNeeded(selectors, frame, timeout) {
  const element = await waitForSelectors(selectors, frame, {
    visible: false,
    timeout,
  });
  if (!element) {
    throw new Error("The element could not be found.");
  }
  await waitForConnected(element, timeout);
  const isInViewport = await element.isIntersectingViewport({ threshold: 0 });
  if (isInViewport) {
    return;
  }
  await element.evaluate((element) => {
    element.scrollIntoView({
      block: "center",
      inline: "center",
      behavior: "auto",
    });
  });
  await waitForInViewport(element, timeout);
}

async function waitForConnected(element, timeout) {
  await waitForFunction(async () => {
    return await element.getProperty("isConnected");
  }, timeout);
}

async function waitForInViewport(element, timeout) {
  await waitForFunction(async () => {
    return await element.isIntersectingViewport({ threshold: 0 });
  }, timeout);
}

async function waitForSelector(selector, frame, options) {
  if (!Array.isArray(selector)) {
    selector = [selector];
  }
  if (!selector.length) {
    throw new Error("Empty selector provided to waitForSelector");
  }
  let element = null;
  for (let i = 0; i < selector.length; i++) {
    const part = selector[i];
    if (element) {
      element = await element.waitForSelector(part, options);
    } else {
      element = await frame.waitForSelector(part, options);
    }
    if (!element) {
      throw new Error("Could not find element: " + selector.join(">>"));
    }
    if (i < selector.length - 1) {
      element = (
        await element.evaluateHandle((el) =>
          el.shadowRoot ? el.shadowRoot : el
        )
      ).asElement();
    }
  }
  if (!element) {
    throw new Error("Could not find element: " + selector.join("|"));
  }
  return element;
}

async function waitForFunction(fn, timeout) {
  let isActive = true;
  const timeoutId = setTimeout(() => {
    isActive = false;
  }, timeout);
  while (isActive) {
    const result = await fn();
    if (result) {
      clearTimeout(timeoutId);
      return;
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  throw new Error("Timed out");
}
// #endregion

function getDateTimeString() {
  let date_time = new Date();

  let date = ("0" + date_time.getDate()).slice(-2);
  let month = ("0" + (date_time.getMonth() + 1)).slice(-2);
  let year = date_time.getFullYear();
  let hours = ("0" + date_time.getHours()).slice(-2);
  let minutes = ("0" + date_time.getMinutes()).slice(-2);
  let seconds = ("0" + date_time.getSeconds()).slice(-2);

  return `${year}-${month}-${date}+${hours}:${minutes}:${seconds}`;
}

function outputStats(minifiedStats) {
  const statJson = JSON.stringify(minifiedStats, null, 4);
  const dateTime = getDateTimeString();
  const statOutput = fs.createWriteStream(
    __dirname.replace("scripts", "data") + `/puppeteer-${dateTime}.json`
  );
  statOutput.write(statJson);
  statOutput.write("\n");
  statOutput.end();
}

/**
 * üöß Automatically generated by Copilot üöß üôè üôè üôè
 * Todo: return a different resource type for tracking pixels
 * Reconsider approach and test against a diverse set of websites
 */
function getAssetTypeFromResource(resource) {
  if (resource.initiatorType === "navigation") return "document";

  const url = resource.name;

  if (url.endsWith(".css")) return "stylesheet";
  if (url.endsWith(".js")) return "script";
  if (url.endsWith(".png")) return "image";

  // Note use of includes as some image URLs end with query parameters
  // Todo: replace with Regex
  if (url.includes(".jpg")) return "image";
  if (url.includes(".jpeg")) return "image";

  if (url.endsWith(".webp")) return "image";
  if (url.endsWith(".gif")) return "image";
  if (url.endsWith(".svg")) return "image";
  if (url.endsWith(".woff")) return "font";
  if (url.endsWith(".woff2")) return "font";
  if (url.endsWith(".ttf")) return "font";
  if (url.endsWith(".otf")) return "font";
  if (url.endsWith(".eot")) return "font";
  if (url.endsWith(".ico")) return "image";
  if (url.endsWith(".mp4")) return "media";
  if (url.endsWith(".webm")) return "media";
  if (url.endsWith(".ogg")) return "media";
  if (url.endsWith(".mp3")) return "media";
  if (url.endsWith(".wav")) return "media";
  if (url.endsWith(".json")) return "json";
  if (url.endsWith(".xml")) return "xml";
  if (url.endsWith(".txt")) return "text";
  if (url.endsWith(".pdf")) return "pdf";

  if (resource.initiatorType === "xmlhttprequest") return "xhr";
  if (resource.initiatorType === "fetch") return "fetch";
  if (resource.initiatorType === "img") return "image";
  if (resource.initiatorType === "script") return "script";
  if (resource.initiatorType === "css") return "stylesheet";
  if (resource.initiatorType === "beacon") return "beacon";

  console.log("No resource type found for:");
  console.log(resource);

  // Todo: handle YouTube embeds and similar with unique resource types.
  // Instead of resource type, is there more relevant info we can return for visualisation?
}

function parsePerformanceResources(resources, page) {
  let output = [];

  for (let i = 0; i < resources.length; i++) {
    let resource = resources[i];

    if (
      resource.entryType === "navigation" ||
      resource.entryType === "resource"
    ) {
      const resourceType = getAssetTypeFromResource(resource);

      output.push({
        url: resource.name,
        resourceType: resourceType,
        transferSize: resource.transferSize,
        page: page,
      });
    }
  }

  return output;
}

function prettify(url) {
  try {
    const urlObject = parse(url);
    urlObject.protocol = chalk.gray(urlObject.protocol.slice(0, -1));
    urlObject.host = chalk.bold(urlObject.host);
    return format(urlObject).replace(/[:/?=#]/g, chalk.gray("$&"));
  } catch (err) {
    // invalid URL delegate error detection
    return url;
  }
}

function log(string) {
  process.stderr.write(string);
}

(async () => {
  const browser = await puppeteer.launch();
  const fetchedResources = [];

  log(`Analysis start!\n`);
  log(`- ${prettify("https://torchbox.com/careers")} `);

  const page = await browser.newPage();
  const client = await page.target().createCDPSession();
  await client.send("Network.setCacheDisabled", {
    cacheDisabled: true,
  });
  await page.setCacheEnabled(false);

  // domContentLoaded doesn't allow secondary scripts to load
  // networkIdle waits for 500ms of no network activity
  // 250ms seems good enough for our purposes - test this on different websites!
  await Promise.all([
    page.goto("https://torchbox.com/careers", {
      waitUntil: "domcontentloaded",
    }),
    page.waitForNetworkIdle({ idleTime: 250 }),
  ]);

  const performanceEntries = JSON.parse(
    await page.evaluate(() => JSON.stringify(window.performance.getEntries()))
  );

  fetchedResources.push(
    ...parsePerformanceResources(performanceEntries, "/careers")
  );

  log(chalk.green("‚úì\n"));

  log(`- ${prettify("https://torchbox.com/careers/jobs")} `);

  // Move from careers homepage to jobs page
  {
    const targetPage = page;
    await scrollIntoViewIfNeeded(
      [
        [
          "#__next > main > div > div.CTA_container__jINIi > a.Button_button__30ukX.Button_radialBackground__zQ6pn.CTA_jobsButton__83AQJ > div.Button_overflowHider__BAMBX",
        ],
        ['xpath///*[@id="__next"]/main/div/div[7]/a[1]/div[1]'],
      ],
      targetPage,
      timeout
    );
    const element = await waitForSelectors(
      [
        [
          "#__next > main > div > div.CTA_container__jINIi > a.Button_button__30ukX.Button_radialBackground__zQ6pn.CTA_jobsButton__83AQJ > div.Button_overflowHider__BAMBX",
        ],
        ['xpath///*[@id="__next"]/main/div/div[7]/a[1]/div[1]'],
      ],
      targetPage,
      { timeout, visible: true }
    );
    await element.click({
      offset: {
        x: 185.8515625,
        y: 24.7265625,
      },
    });
  }

  //
  {
    await page.waitForNetworkIdle({ idleTime: 250 });
    const performanceEntries = JSON.parse(
      await page.evaluate(() => JSON.stringify(window.performance.getEntries()))
    );

    fetchedResources.push(
      ...parsePerformanceResources(performanceEntries, "/careers/jobs")
    );

    log(chalk.green("‚úì\n"));

    log(`- ${prettify("https://torchbox.com/careers/jobs/developer")} `);
  }

  // Move from jobs listing page to developer job page
  {
    const targetPage = page;
    await scrollIntoViewIfNeeded(
      [
        [
          "#__next > main > div > div.Jobs_contentContainer__K4iJm > div > a:nth-child(6) > p.Jobs_jobTitle__PAn4b",
        ],
        ['xpath///*[@id="__next"]/main/div/div[3]/div/a[4]/p[1]'],
        ["text/Senior Python"],
      ],
      targetPage,
      timeout
    );
    const element = await waitForSelectors(
      [
        [
          "#__next > main > div > div.Jobs_contentContainer__K4iJm > div > a:nth-child(6) > p.Jobs_jobTitle__PAn4b",
        ],
        ['xpath///*[@id="__next"]/main/div/div[3]/div/a[4]/p[1]'],
        ["text/Senior Python"],
      ],
      targetPage,
      { timeout, visible: true }
    );
    await element.click({
      offset: {
        x: 38.8515625,
        y: 40.7109375,
      },
    });
  }
  {
    await page.waitForNetworkIdle({ idleTime: 250 });
    const performanceEntries = JSON.parse(
      await page.evaluate(() => JSON.stringify(window.performance.getEntries()))
    );

    fetchedResources.push(
      ...parsePerformanceResources(
        performanceEntries,
        "/careers/jobs/developer"
      )
    );

    log(chalk.green("‚úì\n"));
  }

  await page.close();

  outputStats({
    resources: fetchedResources,
  });

  await browser.close();
})();
