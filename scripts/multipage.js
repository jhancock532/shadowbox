#!/usr/bin/env node
"use strict";

const puppeteer = require("puppeteer");
const chalk = require("chalk");
const fs = require("fs");

/**
 * ğŸš§ Automatically generated by ChatGPT ğŸš§ ğŸ™ ğŸ™ ğŸ™
 */
async function loadJSONFilesFromDirectory(directoryPath) {
  let filesList = [];

  const fs = require("fs");
  const files = await fs.promises.readdir(directoryPath);

  for (let file of files) {
    if (file.endsWith(".json")) {
      const data = await fs.promises.readFile(
        `${directoryPath}/${file}`,
        "utf8"
      );
      filesList.push(JSON.parse(data));
    }
  }

  return filesList;
}

function getDateTimeString() {
  let date_time = new Date();

  let date = ("0" + date_time.getDate()).slice(-2);
  let month = ("0" + (date_time.getMonth() + 1)).slice(-2);
  let year = date_time.getFullYear();
  let hours = ("0" + date_time.getHours()).slice(-2);
  let minutes = ("0" + date_time.getMinutes()).slice(-2);
  let seconds = ("0" + date_time.getSeconds()).slice(-2);

  return `${year}-${month}-${date}+${hours}:${minutes}:${seconds}`;
}

function outputJourneyResults(results, title) {
  const resultsJson = JSON.stringify(results, null, 4);
  const dateTime = getDateTimeString();
  const resultOutputStream = fs.createWriteStream(
    __dirname.replace("scripts", "data/journey-results") +
      `/${title} ${dateTime}.json`
  );
  resultOutputStream.write(resultsJson);
  resultOutputStream.write("\n");
  resultOutputStream.end();
}

/**
 * ğŸš§ Automatically generated by Copilot ğŸš§ ğŸ™ ğŸ™ ğŸ™
 * Todo: return a different resource type for tracking pixels
 * Reconsider approach and test against a diverse set of websites
 */
function getAssetTypeFromResource(resource) {
  if (resource.initiatorType === "navigation") return "document";

  const url = resource.name;

  if (url.endsWith(".css")) return "stylesheet";
  if (url.endsWith(".js")) return "script";
  if (url.endsWith(".png")) return "image";

  // Note use of includes as some image URLs end with query parameters
  // Todo: replace with Regex
  if (url.includes(".jpg")) return "image";
  if (url.includes(".jpeg")) return "image";

  if (url.endsWith(".webp")) return "image";
  if (url.endsWith(".gif")) return "image";
  if (url.endsWith(".svg")) return "image";
  if (url.endsWith(".woff")) return "font";
  if (url.endsWith(".woff2")) return "font";
  if (url.endsWith(".ttf")) return "font";
  if (url.endsWith(".otf")) return "font";
  if (url.endsWith(".eot")) return "font";
  if (url.endsWith(".ico")) return "image";
  if (url.endsWith(".mp4")) return "media";
  if (url.endsWith(".webm")) return "media";
  if (url.endsWith(".ogg")) return "media";
  if (url.endsWith(".mp3")) return "media";
  if (url.endsWith(".wav")) return "media";
  if (url.endsWith(".json")) return "json";
  if (url.endsWith(".xml")) return "xml";
  if (url.endsWith(".txt")) return "text";
  if (url.endsWith(".pdf")) return "pdf";

  if (resource.initiatorType === "xmlhttprequest") return "xhr";
  if (resource.initiatorType === "fetch") return "fetch";
  if (resource.initiatorType === "img") return "image";
  if (resource.initiatorType === "script") return "script";
  if (resource.initiatorType === "css") return "stylesheet";
  if (resource.initiatorType === "beacon") return "beacon";

  console.log("No resource type found for:");
  console.log(resource);

  // Todo: handle YouTube embeds and similar with unique resource types.
  // Instead of resource type, is there more relevant info we can return for visualisation?
}

function parsePerformanceResources(resources) {
  let output = [];

  for (let i = 0; i < resources.length; i++) {
    let resource = resources[i];

    if (
      resource.entryType === "navigation" ||
      resource.entryType === "resource"
    ) {
      const resourceType = getAssetTypeFromResource(resource);

      output.push({
        url: resource.name,
        resourceType: resourceType,
        transferSize: resource.transferSize,
      });
    }
  }

  return output;
}

function log(string) {
  process.stderr.write(string);
}

function findNewResourcesLoaded(stepResources, allPreviousResources) {
  let newResources = [];

  // console.log("Resources loaded in this step: " + stepResources.length);
  // console.log(
  //   "Previous resources from journey: " + allPreviousResources.length
  // );

  for (let i = 0; i < stepResources.length; i++) {
    const newResource = stepResources[i];
    const oldResource = allPreviousResources.find(
      (resource) => resource.url === newResource.url
    );

    if (!oldResource) {
      newResources.push(newResource);
    }
  }

  // console.log("New resources loaded found: " + newResources.length);

  return newResources;
}

async function completeJourney(journey, browser) {
  const initialNavigation = journey.steps.find(
    (step) => step.type === "navigate"
  );

  // Set up page for browsing
  const page = await browser.newPage();
  const client = await page.target().createCDPSession();
  await client.send("Network.setCacheDisabled", {
    cacheDisabled: true,
  });
  await page.setCacheEnabled(false);

  // Navigate to initial page
  await Promise.all([
    page.goto(initialNavigation.url, {
      waitUntil: "domcontentloaded",
    }),
    page.waitForNetworkIdle({ idleTime: 250 }),
  ]);

  const transferredResources = [];

  const performanceEntries = JSON.parse(
    await page.evaluate(() => JSON.stringify(window.performance.getEntries()))
  );

  let allPreviousResources = parsePerformanceResources(performanceEntries);
  let currentURL = initialNavigation.url;

  transferredResources.push({
    type: "initialNavigation",
    url: currentURL,
    resources: allPreviousResources,
  });

  // Complete each journey step
  for (let i = 0; i < journey.steps.length; i++) {
    const step = journey.steps[i];

    if (step.type === "click") {
      const selector = step.selectors[0][0];
      await page.waitForSelector(selector);
      await page.click(selector);

      await page.waitForNavigation({ waitUntil: "domcontentloaded" });
      await page.waitForNetworkIdle({ idleTime: 250 });

      const performanceEntries = JSON.parse(
        await page.evaluate(() =>
          JSON.stringify(window.performance.getEntries())
        )
      );

      const stepResources = parsePerformanceResources(performanceEntries);

      const newResources = findNewResourcesLoaded(
        stepResources,
        allPreviousResources
      );

      allPreviousResources.push(...newResources);

      currentURL = await page.url();

      transferredResources.push({
        type: "click - " + selector,
        url: currentURL,
        resources: newResources,
      });
    }
  }

  await page.close();

  return transferredResources;
}

(async () => {
  const browser = await puppeteer.launch();

  const journeys = await loadJSONFilesFromDirectory(
    __dirname.replace("scripts", "scripts/journeys")
  );

  log(`Analyzing ${journeys.length} journeys...\n`);

  for (let i = 0; i < journeys.length; i++) {
    const journey = journeys[i];
    log(`\n- ${journey.title} `);
    const results = await completeJourney(journey, browser);
    outputJourneyResults(results, journey.title);
    log(chalk.green("âœ“\n"));
  }

  await browser.close();

  log(chalk.blue("\nAnalysis completed.\n"));
})();
