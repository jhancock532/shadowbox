#!/usr/bin/env node
"use strict";

const puppeteer = require("puppeteer");
const chalk = require("chalk");
const fs = require("fs");
const parser = require("xml2json");
const { parse, format } = require("url");
const https = require("https");

async function getResponseSize(url) {
  const protocol = url.startsWith("https") ? https : http;

  return new Promise((resolve, reject) => {
    protocol
      .get(url, (response) => {
        let size = 0;
        response.on("data", (chunk) => {
          size += chunk.length;
        });
        response.on("end", () => {
          resolve(size);
        });
      })
      .on("error", (err) => {
        reject(err);
      });
  });
}

function getDateTimeString() {
  let date_time = new Date();

  let date = ("0" + date_time.getDate()).slice(-2);
  let month = ("0" + (date_time.getMonth() + 1)).slice(-2);
  let year = date_time.getFullYear();
  let hours = ("0" + date_time.getHours()).slice(-2);
  let minutes = ("0" + date_time.getMinutes()).slice(-2);
  let seconds = ("0" + date_time.getSeconds()).slice(-2);

  return `${year}-${month}-${date}+${hours}:${minutes}:${seconds}`;
}

function outputStats(minifiedStats) {
  const statJson = JSON.stringify(minifiedStats, null, 4);
  const dateTime = getDateTimeString();
  const statOutput = fs.createWriteStream(
    __dirname.replace("scripts", "data") + `/puppeteer-${dateTime}.json`
  );
  statOutput.write(statJson);
  statOutput.write("\n");
  statOutput.end();
}

/**
 * üöß Automatically generated by Copilot üöß üôè üôè üôè
 * Todo: return a different resource type for tracking pixels
 * Reconsider approach and test against a diverse set of websites
 */
function getAssetTypeFromResource(resource) {
  if (resource.initiatorType === "navigation") return "document";

  const url = resource.name;

  if (url.endsWith(".css")) return "stylesheet";
  if (url.includes(".min.css")) return "stylesheet";
  if (url.endsWith(".js")) return "script";
  if (url.endsWith(".png")) return "image";

  // Note use of includes as some image URLs end with query parameters
  // Todo: replace with Regex
  if (url.includes(".jpg")) return "image";
  if (url.includes(".jpeg")) return "image";

  if (url.endsWith(".webp")) return "image";
  if (url.endsWith(".gif")) return "image";
  if (url.endsWith(".svg")) return "image";
  if (url.endsWith(".woff")) return "font";
  if (url.endsWith(".woff2")) return "font";
  if (url.endsWith(".ttf")) return "font";
  if (url.endsWith(".otf")) return "font";
  if (url.endsWith(".eot")) return "font";
  if (url.endsWith(".ico")) return "image";
  if (url.endsWith(".mp4")) return "media";
  if (url.endsWith(".webm")) return "media";
  if (url.endsWith(".ogg")) return "media";
  if (url.endsWith(".mp3")) return "media";
  if (url.endsWith(".wav")) return "media";
  if (url.endsWith(".json")) return "json";
  if (url.endsWith(".xml")) return "xml";
  if (url.endsWith(".txt")) return "text";
  if (url.endsWith(".pdf")) return "pdf";

  if (resource.initiatorType === "xmlhttprequest") return "xhr";
  if (resource.initiatorType === "fetch") return "fetch";
  if (resource.initiatorType === "img") return "image";
  if (resource.initiatorType === "script") return "script";
  if (resource.initiatorType === "css") return "stylesheet";
  if (resource.initiatorType === "beacon") return "beacon";

  if (url.includes("www.youtube.com/embed/")) return "embed";
  if (resource.initiatorType === "iframe") return "embed";

  if (url.includes(".css")) return "stylesheet";

  console.log("No resource type found for:");
  console.log(resource);

  // Todo: handle YouTube embeds and similar with unique resource types.
  // Instead of resource type, is there more relevant info we can return for visualisation?
}

async function parsePerformanceResources(resources) {
  let output = {};
  output.requests = [];

  for (let i = 0; i < resources.length; i++) {
    let resource = resources[i];

    if (
      resource.entryType === "navigation" ||
      resource.entryType === "resource"
    ) {
      const resourceType = getAssetTypeFromResource(resource);

      let transferSize = resource.transferSize;

      // Todo: this slows down the analysis significantly, cache these results or estimate them?
      // if (transferSize === 0) {
      //   transferSize = await getResponseSize(resource.name);
      // }

      output.requests.push({
        url: resource.name,
        resourceType: resourceType,
        transferSize: transferSize,
      });
    }
  }

  return output;
}

function prettify(url) {
  try {
    const urlObject = parse(url);
    urlObject.protocol = chalk.gray(urlObject.protocol.slice(0, -1));
    urlObject.host = chalk.bold(urlObject.host);
    return format(urlObject).replace(/[:/?=#]/g, chalk.gray("$&"));
  } catch (err) {
    // invalid URL delegate error detection
    return url;
  }
}

function log(string) {
  process.stderr.write(string);
}

async function fetchSitemap(sitemapURL) {
  const rawXML = await fetch(sitemapURL)
    .then((response) => response.text())
    .catch(function (err) {
      console.log("Unable to fetch -", err);
    });
  log("Parsing sitemap.xml...\n");
  const sitemapItems = JSON.parse(parser.toJson(rawXML)).urlset.url;
  const urls = sitemapItems.map((item) => item.loc);
  console.log("Now analysing " + urls.length + " urls.");
  return urls;
}

(async () => {
  const urls = await fetchSitemap("https://www.rnib.org.uk/sitemap.xml");

  const browser = await puppeteer.launch();
  const analysedPages = [];

  const startTime = new Date();

  for (let i = 0; i < urls.length; i++) {
    try {
      log(
        `${chalk.blue(i)}/${chalk.blue(urls.length)} - ${prettify(urls[i])} `
      );

      const page = await browser.newPage();
      const client = await page.target().createCDPSession();
      await client.send("Network.setCacheDisabled", {
        cacheDisabled: true,
      });
      await page.setCacheEnabled(false);

      // domContentLoaded doesn't allow secondary scripts to load
      // networkIdle waits for 500ms of no network activity
      // 250ms seems good enough for our purposes - test this on different websites!
      await Promise.all([
        page.goto(urls[i], {
          waitUntil: "domcontentloaded",
        }),
        page.waitForNetworkIdle({ idleTime: 250 }),
      ]);

      const performanceEntries = JSON.parse(
        await page.evaluate(() =>
          JSON.stringify(window.performance.getEntries())
        )
      );

      const results = await parsePerformanceResources(performanceEntries);

      results.title = urls[i];
      analysedPages.push(results);
      log(chalk.green("‚úì\n"));

      await page.close();

      if (i % 10 === 0 && i !== 0) {
        const currentTime = new Date();
        const timeElapsed = currentTime - startTime;
        const seconds = Math.floor(timeElapsed / 1000);

        log(chalk.gray(`Evaluated ${i} urls in ${seconds} seconds\n`));
        log(chalk.gray(`Time per page: ${seconds / i} seconds\n`));
        log(
          chalk.gray(
            `Time remaining: ${Math.round(
              (seconds / i) * (urls.length - i)
            )} seconds\n`
          )
        );
      }

      if (i % 100 === 0 && i !== 0) {
        outputStats({
          pages: analysedPages,
        });
      }
    } catch (err) {
      console.log(chalk.red(`Unable to fetch - ${urls[i]}`), err);
    }
  }

  outputStats({
    pages: analysedPages,
  });

  await browser.close();
})();
