#!/usr/bin/env node
"use strict";

const puppeteer = require("puppeteer");
const chalk = require("chalk");
const fs = require("fs");
const parser = require("xml2json");
const { parse, format } = require("url");

function getDateTimeString() {
  let date_time = new Date();

  let date = ("0" + date_time.getDate()).slice(-2);
  let month = ("0" + (date_time.getMonth() + 1)).slice(-2);
  let year = date_time.getFullYear();
  let hours = ("0" + date_time.getHours()).slice(-2);
  let minutes = ("0" + date_time.getMinutes()).slice(-2);
  let seconds = ("0" + date_time.getSeconds()).slice(-2);

  return `${year}-${month}-${date}+${hours}:${minutes}:${seconds}`;
}

function outputStats(minifiedStats) {
  const statJson = JSON.stringify(minifiedStats, null, 4);
  const dateTime = getDateTimeString();
  const statOutput = fs.createWriteStream(
    __dirname.replace("scripts", "data") + `/puppeteer-${dateTime}.json`
  );
  statOutput.write(statJson);
  statOutput.write("\n");
  statOutput.end();
}

/**
 * üöß Automatically generated by Copilot üöß üôè üôè üôè
 * Todo: return a different resource type for tracking pixels
 * Reconsider approach and test against a diverse set of websites
 */
function getAssetTypeFromResource(resource) {
  if (resource.initiatorType === "navigation") return "document";
  if (resource.initiatorType === "iframe") return "document";

  const url = resource.name;

  if (url.endsWith(".css")) return "stylesheet";
  if (url.endsWith(".js")) return "script";
  if (url.endsWith(".png")) return "image";

  // Note use of includes as some image URLs end with query parameters
  // Todo: replace with Regex
  if (url.includes(".jpg")) return "image";
  if (url.includes(".jpeg")) return "image";

  if (url.endsWith(".webp")) return "image";
  if (url.endsWith(".gif")) return "image";
  if (url.endsWith(".svg")) return "image";
  if (url.endsWith(".woff")) return "font";
  if (url.endsWith(".woff2")) return "font";
  if (url.endsWith(".ttf")) return "font";
  if (url.endsWith(".otf")) return "font";
  if (url.endsWith(".eot")) return "font";
  if (url.endsWith(".ico")) return "image";
  if (url.endsWith(".mp4")) return "media";
  if (url.endsWith(".webm")) return "media";
  if (url.endsWith(".ogg")) return "media";
  if (url.endsWith(".mp3")) return "media";
  if (url.endsWith(".wav")) return "media";
  if (url.endsWith(".json")) return "json";
  if (url.endsWith(".xml")) return "xml";
  if (url.endsWith(".txt")) return "text";
  if (url.endsWith(".pdf")) return "pdf";

  if (resource.initiatorType === "xmlhttprequest") return "xhr";
  if (resource.initiatorType === "fetch") return "fetch";
  if (resource.initiatorType === "img") return "image";
  if (resource.initiatorType === "script") return "script";
  if (resource.initiatorType === "css") return "stylesheet";
  if (resource.initiatorType === "beacon") return "beacon";

  console.log("No resource type found for:");
  console.log(resource);

  // Todo: handle YouTube embeds and similar with unique resource types.
  // Instead of resource type, is there more relevant info we can return for visualisation?
}

function parsePerformanceResources(resources) {
  let output = {};
  output.requests = [];

  for (let i = 0; i < resources.length; i++) {
    let resource = resources[i];

    if (
      resource.entryType === "navigation" ||
      resource.entryType === "resource"
    ) {
      const resourceType = getAssetTypeFromResource(resource);

      output.requests.push({
        url: resource.name,
        resourceType: resourceType,
        transferSize: resource.transferSize,
      });
    }
  }

  return output;
}

function prettify(url) {
  try {
    const urlObject = parse(url);
    urlObject.protocol = chalk.gray(urlObject.protocol.slice(0, -1));
    urlObject.host = chalk.bold(urlObject.host);
    return format(urlObject).replace(/[:/?=#]/g, chalk.gray("$&"));
  } catch (err) {
    // invalid URL delegate error detection
    return url;
  }
}

function log(string) {
  process.stderr.write(string);
}

async function fetchSitemap(sitemapURL) {
  const rawXML = await fetch(sitemapURL)
    .then((response) => response.text())
    .catch(function (err) {
      console.log("Unable to fetch -", err);
    });
  log("Parsing sitemap.xml...\n");
  const sitemapItems = JSON.parse(parser.toJson(rawXML)).urlset.url;
  const urls = sitemapItems.map((item) => item.loc);
  console.log("Now analysing " + urls.length + " urls.");
  return urls;
}

(async () => {
  const urls = await fetchSitemap(
    "https://www.childrenshealthireland.ie/sitemap.xml"
  );

  const browser = await puppeteer.launch();
  const analysedPages = [];

  for (let i = 0; i < urls.length; i++) {
    log(`- ${prettify(urls[i])} `);

    const page = await browser.newPage();
    const client = await page.target().createCDPSession();
    await client.send("Network.setCacheDisabled", {
      cacheDisabled: true,
    });
    await page.setCacheEnabled(false);

    // domContentLoaded doesn't allow secondary scripts to load
    // networkIdle waits for 500ms of no network activity
    // 250ms seems good enough for our purposes - test this on different websites!
    await Promise.all([
      page.goto(urls[i], {
        waitUntil: "domcontentloaded",
      }),
      page.waitForNetworkIdle({ idleTime: 250 }),
    ]);

    const performanceEntries = JSON.parse(
      await page.evaluate(() => JSON.stringify(window.performance.getEntries()))
    );

    const results = parsePerformanceResources(performanceEntries);

    results.title = urls[i];
    analysedPages.push(results);
    log(chalk.green("‚úì\n"));

    await page.close();
  }

  outputStats({
    pages: analysedPages,
  });

  await browser.close();
})();
